x = 7 + 11

function Update()
    --print("This is Entity 1 Update\n")
    --print(''..x..'')
    --print(''..Time.deltaTime..'')
    local speed = 10
    Transform.x = Transform.x + speed * Time.deltaTime
    Transform.rotation = Transform.rotation + 45 * Time.deltaTime;

    print(''..self..'')

end


> Player.arcscript -> it's just a human readable and editable string...so simple to work with

var   int health    =  20
var int ammo = 8;
var float something = 23.0;

// Upto 5 scripts can be attached to objects e.g.:
// - MoveSideToSide script
// - Kill player upon collision script
// - Common enemy behaviour script
// scripts are executed in order
// there are only procedures. no variable declarations outside of procs
// built in procedures called by the game:
// - start
// - update
// - oncollision
// - etc.
// user can define their own procedures
// all variables are declared and instantiated upon start
// there are globally accessible singletons
// there are globally accessible built-in functions

// variable types:
// - int
// - float
// - game objects?
// - vectors?
// - lists?
// - structs

// Keywords:
// 

proc Start()
    global int score = 23 // accessible from other objects. persistent.
    local int health = 10 // accessible from same object only. persistent.
    internal int bruh = 9 // accessible from this script only. persistent.
    var int temp = 42 // accessible from within this function only. deallocated upon exit

    MyProcedure  (bruh, 23.6, false)
end

proc Update()
    if Keypressed("")
end

proc (:Update)
end

proc (int : a -> int : fib)
end

proc ((inputs : name)* -> output : name)
end

proc (float:name)
end

proc MyProcedure(int a, float b, bool c)
end

proc (int a, float b, bool c -> int : myProc)
end

proc (void -> void : Update)
{
    
}


Custom structs can be implemented like so:
struct SomeTypeA
{
    int a
    float b
    SomeOtherTypeB
}
For each member in the struct we know their size therefore we know the size of the struct. we also know
their offset from the base. we can allocate memory for size and use offset to access data.

We can have a "run procedure" native function that takes a procedure description and inputs and creates
new stack and runs the procedure

We need object descriptions, and keep track of object instances -> referencable from script like pointers.

// do some tests like fibonacci calculations, etc.


We are creating an imperative language like C, like assembly
thus, the goal of executing the AST is to mutate the machine state.


